package com.android.niapsec.encryption.internal

import android.content.Context
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.InputStream
import java.io.OutputStream
import java.security.GeneralSecurityException
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

/**
 * An EncryptionProvider that uses the standard Android Keystore and JCA (Java Cryptography Architecture)
 * to perform encryption and decryption. It does not use the Tink library.
 *
 * This implementation uses AES-256-GCM for authenticated encryption.
 */
class RawEncryptionProvider(
    private val context: Context,
    private val keyAlias: String,
    private val unlockedDeviceRequired: Boolean
) : EncryptionProvider {

    private val ANDROID_KEYSTORE = "AndroidKeyStore"
    private val KEY_ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
    private val BLOCK_MODE = KeyProperties.BLOCK_MODE_GCM
    private val PADDING = KeyProperties.ENCRYPTION_PADDING_NONE
    private val TRANSFORMATION = "$KEY_ALGORITHM/$BLOCK_MODE/$PADDING"

    // 96 bits (12 bytes) is the recommended IV size for GCM.
    private val GCM_IV_LENGTH_BYTES = 12
    // 128 bits is a standard tag size for GCM.
    private val GCM_TAG_LENGTH_BITS = 128

    private val keyStore: KeyStore = KeyStore.getInstance(ANDROID_KEYSTORE).apply { load(null) }

    init {
        if (!keyStore.containsAlias(keyAlias)) {
            generateKey()
        }
    }

    private fun generateKey() {
        val keyGenerator = KeyGenerator.getInstance(KEY_ALGORITHM, ANDROID_KEYSTORE)
        val spec = KeyGenParameterSpec.Builder(keyAlias, KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(BLOCK_MODE)
            .setEncryptionPaddings(PADDING)
            .setKeySize(256)
            .setRandomizedEncryptionRequired(true) // Recommended for GCM
            .setUserAuthenticationRequired(unlockedDeviceRequired)
            .build()
        keyGenerator.init(spec)
        keyGenerator.generateKey()
    }

    private fun getSecretKey(): SecretKey {
        return keyStore.getKey(keyAlias, null) as SecretKey
    }

    private fun encrypt(plaintext: ByteArray): ByteArray {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        // A new IV is generated by the provider on each encryption.
        cipher.init(Cipher.ENCRYPT_MODE, getSecretKey())
        val iv = cipher.iv
        val ciphertext = cipher.doFinal(plaintext)

        // Prepend the IV to the ciphertext. It's needed for decryption.
        val result = ByteArray(iv.size + ciphertext.size)
        System.arraycopy(iv, 0, result, 0, iv.size)
        System.arraycopy(ciphertext, 0, result, iv.size, ciphertext.size)
        return result
    }

    private fun decryptToBytes(ciphertext: ByteArray): ByteArray {
        if (ciphertext.size <= GCM_IV_LENGTH_BYTES) {
            throw GeneralSecurityException("Invalid ciphertext: too short")
        }

        // Extract the IV from the beginning of the ciphertext.
        val iv = ciphertext.copyOfRange(0, GCM_IV_LENGTH_BYTES)
        val actualCiphertext = ciphertext.copyOfRange(GCM_IV_LENGTH_BYTES, ciphertext.size)

        val cipher = Cipher.getInstance(TRANSFORMATION)
        val spec = GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv)
        cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), spec)

        return cipher.doFinal(actualCiphertext)
    }

    override fun encrypt(file: File): OutputStream {
        return object : ByteArrayOutputStream() {
            override fun close() {
                super.close()
                val plaintext = toByteArray()
                val encryptedData = encrypt(plaintext)
                file.writeBytes(encryptedData)
            }
        }
    }

    override fun encrypt(plaintext: String): ByteArray {
        return encrypt(plaintext.toByteArray())
    }

    override fun decrypt(file: File): InputStream {
        val fileBytes = file.readBytes()
        val plaintextBytes = decryptToBytes(fileBytes)
        return ByteArrayInputStream(plaintextBytes)
    }

    override fun decrypt(ciphertext: ByteArray): String {
        val plaintextBytes = decryptToBytes(ciphertext)
        return String(plaintextBytes)
    }

    override fun destroy() {
        if (keyStore.containsAlias(keyAlias)) {
            keyStore.deleteEntry(keyAlias)
        }
    }
}
